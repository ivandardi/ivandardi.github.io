<!doctype html><html data-theme=light lang=en><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://ivandardi.github.io name=base><title>Rust has no implicit return â€¢ Programming Insights</title><link href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 105 55"><text y=".7em" font-size="82">ðŸ¦€</text></svg>' rel=icon><link href="https://ivandardi.github.io/inter_subset_en.css?h=d8cf4ad058d6c3a4015b" rel=stylesheet><link href="https://ivandardi.github.io/main.css?h=c7a5c41e19bed805f524" rel=stylesheet><link href="https://ivandardi.github.io/skins/teal.css?h=bd19e558a52d678a50de" rel=stylesheet><meta content="light dark" name=color-scheme><meta content="How returns work in Rust, and how implicit returns are a myth." name=description><meta content="How returns work in Rust, and how implicit returns are a myth." property=og:description><meta content="index, nofollow" name=robots><meta content="Rust has no implicit return" property=og:title><meta content=article property=og:type><meta content=en_GB property=og:locale><meta content=https://ivandardi.github.io/blog/rust-has-no-implicit-returns/ property=og:url><meta content="Programming Insights" property=og:site_name><meta content="default-src 'self';font-src 'self' data:;img-src 'self' https://* data:;style-src 'self' 'unsafe-inline';frame-src https://www.youtube-nocookie.com;connect-src 'self';script-src 'self' 'self'" http-equiv=Content-Security-Policy><noscript><link href=https://ivandardi.github.io/no_js.css rel=stylesheet></noscript><script src=https://ivandardi.github.io/js/initializeTheme.min.js></script><script defer src=https://ivandardi.github.io/js/themeSwitcher.min.js></script><script src="https://ivandardi.github.io/search_index.en.js?h=59bec7f14c8e2894e965" defer></script><script src="https://ivandardi.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><header><nav class=navbar><div class=nav-title><a class=home-title href=https://ivandardi.github.io>Programming Insights</a></div><div class=nav-navs><ul><li><a class="nav-links no-hover-padding" href=https://ivandardi.github.io/about/> about </a><li><a class="nav-links no-hover-padding" href=https://ivandardi.github.io/services/> services </a><li><a class="nav-links no-hover-padding" href=https://ivandardi.github.io/blog/> blog </a><li><a class="nav-links no-hover-padding" href=https://ivandardi.github.io/tags/> tags </a><li><a class="nav-links no-hover-padding" href=https://ivandardi.github.io/archive/> archive </a><li class=js><div aria-label="Click or press $SHORTCUT to open search" class="search-icon interactive-icon" title="Click or press $SHORTCUT to open search" id=search-button role=button tabindex=0><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"/></svg></div><li class="theme-switcher-wrapper js"><div aria-label="Toggle dark mode" title="Toggle dark/light mode" aria-pressed=false class=theme-switcher role=button tabindex=0></div><div aria-label="Reset mode to default" class="theme-resetter arrow" title="Reset mode to default" aria-hidden=true role=button tabindex=0></div></ul></div></nav></header><div class=content><main><article><h1 class=article-title>Rust has no implicit return</h1><ul class=meta><li>9th Nov 2024</li>Â â€¢Â <li title="1199 words">6 min read</li>Â â€¢Â <li>Tags:Â <li><a href=https://ivandardi.github.io/tags/rust/>rust</a>,Â <li><a href=https://ivandardi.github.io/tags/implicit-return/>implicit return</a></ul><ul class="meta last-updated"><li>Updated on 9th Nov 2024</li> â€¢Â <li><a href=https://github.com/ivandardi/ivandardi.github.io/commits/main/content/blog/rust-has-no-implicit-returns.md>See changes<small>Â <span class=arrow-corner>â†—</span></small></a></ul><section class=body><p>One of the things that makes Rust somewhat unique compared to other languages is its approach to returns. If you've come from languages like Python or JavaScript, you might be used to always using the <code>return</code> keyword whenever you want to return something. However, when it comes to Rust, you can return values from a function without using the <code>return</code> keyword. This behavior is usually known as "implicit return" and can be very confusing for some people.<blockquote><h2 id=disclaimer><a aria-label="Anchor link for: disclaimer" class="header-anchor no-hover-padding" href=#disclaimer><span aria-hidden=true class=link-icon></span></a> Disclaimer</h2><p>In this blog post I'll build and explain my own mental framework for what "implicit return" means, and the derivations that come from it. I acknowledge what I say here may not be 100% accurate sometimes. I may write something that's intentionally slightly incorrect in order to simplify the explanation and make it easier to understand. Sometimes I'll be plain wrong due to pure ignorance. Please excuse me when that happens, and I appreciate feedback whenever something needs fixing.</blockquote><p>With that out of the way, let's understand why "implicit returns" exist in Rust!<h2 id=expressions-everywhere><a aria-label="Anchor link for: expressions-everywhere" class="header-anchor no-hover-padding" href=#expressions-everywhere><span aria-hidden=true class=link-icon></span></a> Expressions Everywhere</h2><p>In Rust, I like to think that everything is an expression. Sure, that may not be completely true, since macros, language items and other things exist. But, generally speaking, the simplification that everything is an expression can be useful.<p>A special mention here are <code>let</code> statements. As the name suggests, they are statements instead of expressions. However, I like to see them as assignment expressions that evaluate to the unit type <code>()</code>. In C, for example, you can write <code>a = b = c = 10</code>. That's because <code>c = 10</code> evaluates to <code>10</code>, and then <code>b = c = 10</code> turns into <code>b = 10</code>, which also gets evaluated to <code>10</code>, and so on. That doesn't work in Rust because the the <code>let</code> statement evaluates to <code>()</code>, and so you'd assign one variable the value <code>10</code> and the next one the value <code>()</code>. Again, this is simplifying a lot, but it helps build the mental framework for what comes next.<p>Expressions can be arithmetic expressions, function calls, if statements, and <a href=https://doc.rust-lang.org/reference/expressions.html>a lot more</a>. They can also be recursively nested combinations of other expressions. For example, the <code>5 + 3</code> and the <code>10</code> are nested expressions inside the expression of the function call:<pre class=language-rust data-lang=rust style=color:#6c7079;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#cd74e8>fn </span><span style=color:#5cb3fa>nested_expressions</span><span style=color:#abb2bf>() -> </span><span style=color:#cd74e8>i32 </span><span style=color:#abb2bf>{
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>let</span><span style=color:#abb2bf> result </span><span style=color:#adb7c9>= </span><span style=color:#5ebfcc>function_call</span><span style=color:#abb2bf>(</span><span style=color:#db9d63>5 </span><span style=color:#adb7c9>+ </span><span style=color:#db9d63>3</span><span style=color:#abb2bf>, </span><span style=color:#db9d63>10</span><span style=color:#abb2bf>);
</span><span style=color:#abb2bf>    result
</span><span style=color:#abb2bf>}
</span></code></pre><p>More importantly, expressions usually come in expression blocks. For example:<pre class=language-rust data-lang=rust style=color:#6c7079;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#cd74e8>fn </span><span style=color:#5cb3fa>expression_blocks</span><span style=color:#abb2bf>() -> </span><span style=color:#cd74e8>i32 </span><span style=color:#abb2bf>{
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>let</span><span style=color:#abb2bf> result </span><span style=color:#adb7c9>= </span><span style=color:#abb2bf>{
</span><span style=color:#abb2bf>        </span><span style=color:#cd74e8>let</span><span style=color:#abb2bf> a </span><span style=color:#adb7c9>= </span><span style=color:#db9d63>2</span><span style=color:#abb2bf>;
</span><span style=color:#abb2bf>        </span><span style=color:#cd74e8>let</span><span style=color:#abb2bf> b </span><span style=color:#adb7c9>= </span><span style=color:#db9d63>10</span><span style=color:#abb2bf>;
</span><span style=color:#abb2bf>        a </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> b
</span><span style=color:#abb2bf>    };
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>    result
</span><span style=color:#abb2bf>}
</span></code></pre><p>The code that is being assigned to the <code>result</code> variable is what I call an expression block. It contains a sequence of expressions, separated by semicolons, wrapped around in curly braces <code>{}</code>. Expression blocksâ€”generally just called "blocks"â€”are always delimited by a pair of curly braces. They can contain 0, 1 or more expressions, and they can also contain other expression blocks.<p>If you think about it, functions always have a pair of curly braces after the function signature. That is also an expression block! In fact, you can syntactically see functions as:<pre class=language-rust data-lang=rust style=color:#6c7079;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#cd74e8>fn </span><span style=color:#5cb3fa>function_name</span><span style=color:#abb2bf>() -> ReturnType &LTexpression_block>
</span></code></pre><p>I am aware that they're officially called "block expressions" instead of "expression blocks". However, I like visualizing them as blocksâ€”delimited by curly braces <code>{}</code>â€”that contain expressions, which is why I call them that way. And expression blocks are important for this mental framework that I'm building because they have a very important property:</p><br><blockquote><h3 id=expression-blocks-always-evaluate-to-the-last-expression-in-the-expression-sequence-it-contains><a aria-label="Anchor link for: expression-blocks-always-evaluate-to-the-last-expression-in-the-expression-sequence-it-contains" class="header-anchor no-hover-padding" href=#expression-blocks-always-evaluate-to-the-last-expression-in-the-expression-sequence-it-contains><span aria-hidden=true class=link-icon></span></a> <strong>Expression blocks always evaluate to the last expression in the expression sequence it contains.</strong></h3></blockquote><br><br><p>For us to be able to fully understand what that means, we first must look at what semicolons do.<h2 id=the-role-of-the-semicolon><a aria-label="Anchor link for: the-role-of-the-semicolon" class="header-anchor no-hover-padding" href=#the-role-of-the-semicolon><span aria-hidden=true class=link-icon></span></a> The Role of the Semicolon (;)</h2><p>Here's a basic example of a Rust function:<pre class=language-rust data-lang=rust style=color:#6c7079;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#cd74e8>fn </span><span style=color:#5cb3fa>sum</span><span style=color:#abb2bf>(</span><span style=color:#eb6772>a</span><span style=color:#abb2bf>: </span><span style=color:#cd74e8>i32</span><span style=color:#abb2bf>, </span><span style=color:#eb6772>b</span><span style=color:#abb2bf>: </span><span style=color:#cd74e8>i32</span><span style=color:#abb2bf>) -> </span><span style=color:#cd74e8>i32 </span><span style=color:#abb2bf>{
</span><span style=color:#abb2bf>    a </span><span style=color:#adb7c9>+</span><span style=color:#abb2bf> b
</span><span style=color:#abb2bf>}
</span></code></pre><p>In this example, there's no <code>return</code> keyword, but the function still returns the value of <code>a + b</code>. This works because <code>a + b</code> is an expression, and it's the last thing in the expression block of the function. More generally speaking:</p><br><blockquote><h3 id=rust-functions-always-return-the-evaluation-of-its-expression-block><a aria-label="Anchor link for: rust-functions-always-return-the-evaluation-of-its-expression-block" class="header-anchor no-hover-padding" href=#rust-functions-always-return-the-evaluation-of-its-expression-block><span aria-hidden=true class=link-icon></span></a> <strong>Rust functions always return the evaluation of its expression block</strong>.</h3></blockquote><br><br><p>Notice the absence of a semicolon (;) at the end of the <code>a + b</code> lineâ€”this is what "makes" the Rust function return the expression and is known as the "implicit return" that everyone talks about. But how does that really work? That's where semicolons come in.<p>In Rust, the semicolon (;) doesn't simply mark an "end of statement" like in some other languages. Instead, it's used to separate expressions. Here's a more detailed example to show how this works:<pre class=language-rust data-lang=rust style=color:#6c7079;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#cd74e8>fn </span><span style=color:#5cb3fa>example</span><span style=color:#abb2bf>() -> </span><span style=color:#cd74e8>i32 </span><span style=color:#abb2bf>{
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>let</span><span style=color:#abb2bf> x </span><span style=color:#adb7c9>= </span><span style=color:#db9d63>5</span><span style=color:#abb2bf>;
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>let</span><span style=color:#abb2bf> y </span><span style=color:#adb7c9>= </span><span style=color:#db9d63>10</span><span style=color:#abb2bf>;
</span><span style=color:#abb2bf>    x </span><span style=color:#adb7c9>+</span><span style=color:#abb2bf> y;
</span><span style=color:#abb2bf>}
</span></code></pre><p>At first glance, you might think that this function would "implicitly" return <code>15</code> (since <code>x + y</code> is <code>15</code>)â€”but it actually returns <code>()</code>, which creates a compiler error. Why? Because <code>x + y;</code> has a semicolon at the end.<p>Let's rewrite the function's expression block in a different way and label each expression in it:<pre class=language-rust data-lang=rust style=color:#6c7079;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#cd74e8>let</span><span style=color:#abb2bf> x </span><span style=color:#adb7c9>= </span><span style=color:#db9d63>5 </span><span style=color:#abb2bf>; </span><span style=color:#cd74e8>let</span><span style=color:#abb2bf> y </span><span style=color:#adb7c9>= </span><span style=color:#db9d63>10 </span><span style=color:#abb2bf>; x </span><span style=color:#adb7c9>+</span><span style=color:#abb2bf> y ; Îµ
</span><span style=color:#adb7c9>+-------+   +--------+   +---+   +
</span><span style=color:#abb2bf>    A            B         C     D
</span></code></pre><p>As explained above, <code>let</code> statementsâ€”and statements in generalâ€”evaluate to the unit type <code>()</code>.<p>Expression <code>C</code> evaluates to <code>15</code>. However, the value of that expression isn't being saved anywhere, so it just gets discarded.<p>Now, for expression <code>D</code>, I'm borrowing a concept from the literature. If you've read anything about writing compilers, you may have come across the symbol <code>Îµ</code>. That symbol represents an empty string. Note that it's different from the empty string <code>""</code>. The <code>Îµ</code> is necessary because the semicolon is an expression <em>separator</em>, meaning it must appear with an expression on either side. In the example, we don't have a final expression that the last semicolon can separate from the rest. Therefore, the Rust compiler adds <code>Îµ</code> at the end of the expression list to allow the last semicolon to separate two expressions as intended.<p>And with all of that in mind, we reach the crucial piece of information:</p><br><blockquote><h3 id=e-gets-evaluated-to><a aria-label="Anchor link for: e-gets-evaluated-to" class="header-anchor no-hover-padding" href=#e-gets-evaluated-to><span aria-hidden=true class=link-icon></span></a> <strong><code>Îµ</code> gets evaluated to <code>()</code></strong>.</h3></blockquote><br><br><p>To illustrate that, let's rewrite the expression block, this time replacing the code with the values of their respective evaluations:<pre class=language-rust data-lang=rust style=color:#6c7079;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#abb2bf>    ()    ;     ()     ;  </span><span style=color:#db9d63>15   </span><span style=color:#abb2bf>; ()
</span><span style=color:#adb7c9>+-------+   +--------+   +---+   +
</span><span style=color:#abb2bf>    A            B         C     D
</span></code></pre><p>We can observe that the statements got evaluated to <code>()</code>, the sum expression got evaluated to <code>15</code>, and the <code>Îµ</code> got evaluated to <code>()</code>. And because it's the last value in the sequence, that's what the Rust function returns. With that in mind, we now know why this compiles:<pre class=language-rust data-lang=rust style=color:#6c7079;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#cd74e8>fn </span><span style=color:#5cb3fa>main</span><span style=color:#abb2bf>() {
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>let</span><span style=color:#abb2bf> result: () </span><span style=color:#adb7c9>= </span><span style=color:#5ebfcc>example_unit_type</span><span style=color:#abb2bf>();
</span><span style=color:#abb2bf>}
</span><span style=color:#abb2bf>
</span><span style=color:#5f697a;font-style:italic>// Functions without a written return type have `-> ()` as their return type.
</span><span style=color:#cd74e8>fn </span><span style=color:#5cb3fa>example_unit_type</span><span style=color:#abb2bf>() {
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>let</span><span style=color:#abb2bf> x </span><span style=color:#adb7c9>= </span><span style=color:#db9d63>5</span><span style=color:#abb2bf>;
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>let</span><span style=color:#abb2bf> y </span><span style=color:#adb7c9>= </span><span style=color:#db9d63>10</span><span style=color:#abb2bf>;
</span><span style=color:#abb2bf>    x </span><span style=color:#adb7c9>+</span><span style=color:#abb2bf> y;
</span><span style=color:#abb2bf>}
</span></code></pre><p>And for completeness, let's remove the semicolon at the end of the <code>example</code> function and do the same steps again:<pre class=language-rust data-lang=rust style=color:#6c7079;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#cd74e8>fn </span><span style=color:#5cb3fa>example_fixed</span><span style=color:#abb2bf>() -> </span><span style=color:#cd74e8>i32 </span><span style=color:#abb2bf>{
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>let</span><span style=color:#abb2bf> x </span><span style=color:#adb7c9>= </span><span style=color:#db9d63>5</span><span style=color:#abb2bf>;
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>let</span><span style=color:#abb2bf> y </span><span style=color:#adb7c9>= </span><span style=color:#db9d63>10</span><span style=color:#abb2bf>;
</span><span style=color:#abb2bf>    x </span><span style=color:#adb7c9>+</span><span style=color:#abb2bf> y
</span><span style=color:#abb2bf>}
</span></code></pre><pre class=language-rust data-lang=rust style=color:#6c7079;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#cd74e8>let</span><span style=color:#abb2bf> x </span><span style=color:#adb7c9>= </span><span style=color:#db9d63>5 </span><span style=color:#abb2bf>; </span><span style=color:#cd74e8>let</span><span style=color:#abb2bf> y </span><span style=color:#adb7c9>= </span><span style=color:#db9d63>10 </span><span style=color:#abb2bf>; x </span><span style=color:#adb7c9>+</span><span style=color:#abb2bf> y
</span><span style=color:#adb7c9>+-------+   +--------+   +---+
</span><span style=color:#abb2bf>    A            B         C
</span></code></pre><pre class=language-rust data-lang=rust style=color:#6c7079;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#abb2bf>    ()    ;     ()     ;  </span><span style=color:#db9d63>15
</span><span style=color:#adb7c9>+-------+   +--------+   +---+
</span><span style=color:#abb2bf>    A            B         C
</span></code></pre><p>Because the last semicolon is gone, all semicolons are already separating two expressions as intended, so there's no need add <code>Îµ</code> at the end of the expression sequence. That entire expression block gets evaluated as <code>15</code>, since it is the final value of the block's expression sequence. And because functions always return the evaluation of their expression block, this function ends up returning <code>15</code>.<h2 id=final-thoughts><a aria-label="Anchor link for: final-thoughts" class="header-anchor no-hover-padding" href=#final-thoughts><span aria-hidden=true class=link-icon></span></a> Final Thoughts</h2><p>So, what's the takeaway? Rust doesn't have implicit returns because expression blocks evaluate to the last expression it contains, which then get returned by functions. And whenever a semicolon isn't separating two expressions, the Rust compiler appends an <code>Îµ</code>, which gets evaluated to <code>()</code>.<p>This isn't the easiest or the most intuitive rule to learn and remember. It's commonly interpreted as "If you want to return a value, you can remove the semicolon from the last expression and it'll get implicitly returned". However, that way of phrasing it doesn't fully explain what's going on under the hood, which can create a lot of confusion and misconceptions about Rust's "implicit returns". Hopefully the mental framework that I explained in article helps you better understand how returns actually work in Rust.</section></article></main><span class=hidden id=copy-success> Copied! </span><span class=hidden id=copy-init> Copy code to clipboard </span><script defer src=https://ivandardi.github.io/js/copyCodeToClipboard.min.js></script></div><footer><section><nav class="socials nav-navs"><ul><li class=js><a class="nav-links no-hover-padding social" data-encoded-email="aXZhbmJvcmdpYWRhcmRpQGdtYWlsLmNvbQ==" href=#><img alt=email loading=lazy src=https://ivandardi.github.io/social_icons/email.svg title=email> </a><li><a class="nav-links no-hover-padding social" rel=" me" href=https://github.com/ivandardi/> <img alt=github loading=lazy src=https://ivandardi.github.io/social_icons/github.svg title=github> </a><li><a class="nav-links no-hover-padding social" rel=" me" href=https://linkedin.com/ivan-dardi/> <img alt=linkedin loading=lazy src=https://ivandardi.github.io/social_icons/linkedin.svg title=linkedin> </a></ul></nav><nav class=nav-navs></nav><div class=credits><small> Powered by <a href=https://www.getzola.org>Zola</a> & <a href=https://github.com/welpo/tabi>tabi</a> â€¢ <a href=https://github.com/ivandardi/ivandardi.github.io> Site source </a></small></div></section><script async src=https://ivandardi.github.io/js/decodeMail.min.js></script><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><h1 class=visually-hidden id=modalTitle>Search</h1><div id=modal-content><div id=searchBar><div aria-hidden=true class=search-icon><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"/></svg></div><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Searchâ€¦ role=combobox spellcheck=false><div class="close-icon interactive-icon" title="Clear search" id=clear-search role=button tabindex=0><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></div></div><div id=results-container><div id=results-info><span id=zero_results> No results</span><span id=one_results> $NUMBER result</span><span id=many_results> $NUMBER results</span><span id=two_results> $NUMBER results</span><span id=few_results> $NUMBER results</span></div><div id=results role=listbox></div></div></div></div></footer>